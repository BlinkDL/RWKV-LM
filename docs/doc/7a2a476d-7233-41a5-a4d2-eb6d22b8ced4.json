{
    "summary": "The code imports libraries, defines a tokenizing class, utilizes Fermat's Little Theorem and Miller-Rabin primality test for prime number calculation, performs verification process to determine if a given number is prime, and returns True or False accordingly.",
    "details": [
        {
            "comment": "This code imports necessary libraries and defines a class for tokenizing text using either pre-trained tokenizers or custom word tables. It also records time usage for optimization purposes.",
            "location": "\"/media/root/Prima/works/RWKV-LM/docs/src/RWKV-v4neo/src/utils.py\":0-29",
            "content": "import json, time, random, os\nimport numpy as np\nimport torch\nfrom torch.nn import functional as F\ntime_slot = {}\ntime_ref = time.time_ns()\ndef record_time(name):\n    if name not in time_slot:\n        time_slot[name] = 1e20\n    tt = (time.time_ns() - time_ref) / 1e9\n    if tt < time_slot[name]:\n        time_slot[name] = tt\nclass TOKENIZER():\n    def __init__(self, WORD_NAME, UNKNOWN_CHAR='\\ue083'):\n        if 'list' in str(type(WORD_NAME)):\n            self.charMode = False\n            if WORD_NAME[0] == WORD_NAME[1]:\n                from transformers import PreTrainedTokenizerFast\n                self.tokenizer = PreTrainedTokenizerFast(tokenizer_file=WORD_NAME[0])\n            else:\n                from transformers import GPT2TokenizerFast\n                self.tokenizer = GPT2TokenizerFast(WORD_NAME[0], WORD_NAME[1])\n            self.vocab_size = len(self.tokenizer)\n        else:\n            self.charMode = True\n            with open(WORD_NAME + '.json', \"r\", encoding=\"utf-16\") as result_file:\n                self.word_table = json.load(result_file)"
        },
        {
            "comment": "This code snippet is part of a model for text generation. The 'utils' class contains methods to refine the context by removing extra whitespace and unwanted characters, set vocabulary size based on the word table, map words to integers and vice versa, and sample logits to generate text using softmax function with option to specify temperature and top probabilities for specific characters.",
            "location": "\"/media/root/Prima/works/RWKV-LM/docs/src/RWKV-v4neo/src/utils.py\":31-59",
            "content": "            self.vocab_size = len(self.word_table)\n            self.stoi = {v: int(k) for k, v in self.word_table.items()}\n            self.itos = {int(k): v for k, v in self.word_table.items()}\n            self.UNKNOWN_CHAR = self.stoi[UNKNOWN_CHAR]\n    def refine_context(self, context):\n        context = context.strip().split('\\n')\n        for c in range(len(context)):\n            context[c] = context[c].strip().strip('\\u3000').strip('\\r')\n        context = list(filter(lambda c: c != '', context))\n        context = '\\n' + ('\\n'.join(context)).strip()\n        if context == '':\n            context = '\\n'\n        return context\n    def sample_logits(self, out, x, ctx_len, temperature=1.0, top_p_usual=None, top_p_newline=None):\n        # out[self.UNKNOWN_CHAR] = -float('Inf')\n        lastChar = int(x[-1])\n        probs = F.softmax(out, dim=-1)\n        if self.charMode:\n            if self.itos[lastChar] == '\\n':\n                top_p = top_p_newline\n            else:\n                top_p = top_p_usual\n        else:"
        },
        {
            "comment": "This function calculates prime numbers using Fermat's Little Theorem and Miller-Rabin primality test. The prime number check is done only if the environment variable RWKV_RUN_DEVICE is set to \"cpu\". If not, it uses torch.multinomial() for selection.",
            "location": "\"/media/root/Prima/works/RWKV-LM/docs/src/RWKV-v4neo/src/utils.py\":60-84",
            "content": "            top_p = top_p_usual\n        if os.environ[\"RWKV_RUN_DEVICE\"] == \"cpu\":\n            probs = probs.numpy()\n            sorted_probs = np.sort(probs)[::-1]\n            cumulative_probs = np.cumsum(sorted_probs)\n            cutoff = float(sorted_probs[np.argmax(cumulative_probs > top_p)])\n            probs[probs < cutoff] = 0\n            if temperature != 1.0:\n                probs = probs.pow(1.0 / temperature)\n            probs = probs / np.sum(probs)\n            out = np.random.choice(a=len(probs), p=probs)\n            return out\n        else:\n            sorted_probs = torch.sort(probs, descending=True)[0]\n            cumulative_probs = torch.cumsum(sorted_probs, dim=-1).cpu().numpy()\n            cutoff = float(sorted_probs[np.argmax(cumulative_probs > top_p)])\n            probs[probs < cutoff] = 0\n            if temperature != 1.0:\n                probs = probs.pow(1.0 / temperature)\n            out = torch.multinomial(probs, num_samples=1)[0]\n            return out\ndef MaybeIsPrime(number):\n    if FermatPrimalityTest(number) and MillerRabinPrimalityTest(number):"
        },
        {
            "comment": "The code contains three functions: 1) FermatPrimalityTest checks if a number is prime using the Fermat Little Theorem; it returns True if number is greater than 1, and False otherwise. 2) MillerRabinPrimalityTest checks if a number is prime using the Miller-Rabin algorithm; it returns True for number=2, False for number=1 or even numbers, and starts by simplifying the odd part of the number. 3) The code uses a while loop to calculate the odd part of the number and determines the maximum iterations needed. The function then uses another loop to randomly select randomNumbers and test them for primality using the calculated parameters.",
            "location": "\"/media/root/Prima/works/RWKV-LM/docs/src/RWKV-v4neo/src/utils.py\":85-121",
            "content": "        return True\n    else:\n        return False\ndef FermatPrimalityTest(number):\n    if number > 1:\n        for time in range(3):\n            randomNumber = random.randint(2, number) - 1\n            if pow(randomNumber, number - 1, number) != 1:\n                return False\n        return True\n    else:\n        return False\ndef MillerRabinPrimalityTest(number):\n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    oddPartOfNumber = number - 1\n    timesTwoDividNumber = 0\n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber // 2\n        timesTwoDividNumber = timesTwoDividNumber + 1\n    for time in range(3):\n        while True:\n            randomNumber = random.randint(2, number) - 1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            iterationNumber = 1"
        },
        {
            "comment": "This code performs a verification process where it checks if the given number can be determined as prime. It does this by iterating through a range of values, squaring a random number and calculating its modulo with the input number until either all iterations are completed or the value no longer matches the expected result. If the latter occurs, it returns False indicating that the number is not prime. Otherwise, it returns True.",
            "location": "\"/media/root/Prima/works/RWKV-LM/docs/src/RWKV-v4neo/src/utils.py\":123-129",
            "content": "            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                iterationNumber = iterationNumber + 1\n            if randomNumberWithPower != (number - 1):\n                return False\n    return True"
        }
    ]
}